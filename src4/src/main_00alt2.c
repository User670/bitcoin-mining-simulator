#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <string.h>
#include <inttypes.h>
#include <fcntl.h>

#include <sha2.h>
#include <bitcoin_utils.h>
#include <data_utils.h>
#include <debug_utils.h>


// for multiprocessing
// mines a single header
// @params
//  *block: pointer to a block to be mined
//  *target: pointer to a expanded target
// @return
//  void
void mine_single_block(BitcoinHeader* block, const char* target){
    int i=0;
    for(; i<=2147483647; i++){
        block->nonce=i;
        if(is_good_block(block, target)){
            printf("CHILD PROCESS: nonce found %d\n", i);
            break;
        }
        
    }
}

typedef struct{
    int result_found;
    BitcoinHeader block;
    char* target;
    int no_more_jobs;
}SharedData1;

void process_miner(int id, SharedData1* sd){
    printf("CHILD %d: spawned\n",id);
    // prepare semaphore references
    sem_t* issue_job_sync_sem=sem_open("/issuejob", O_RDWR);
    sem_t* job_end_sync_sem=sem_open("/jobend", O_RDWR);
    sem_t* result_found_mutex=sem_open("/resultfound", O_RDWR);
    
    // prepare vars
    BitcoinHeader working_block;
    
    // main loop
    while(1){
        // wait for parent to issue job and release lock
        //printf("CHILD %d: I'm waiting for parent to release issuejob\n",id);
        sem_wait(issue_job_sync_sem);
        //printf("CHILD %d: I'm released from issuejob\n",id);
        // check `sd` for no-more-jobs signal
        if(sd->no_more_jobs){
            printf("CHILD %d: No more job flag raised, breaking out of main loop\n", id);
            break;
        }
        
        // make a copy of the block so that it doesn't mess with other processes
        working_block=sd->block;
        
        //printf("CHILD %d: I'm entering main loop\n",id);
        for(int i=0; i<=2147483647; i++){
            if(sd->result_found){
                // could have merged the conditional in the loop, but
                // 1, I don't like cramming conditions in the loop,
                // 2, I can print stuff here this way
                printf("CHILD %d: Someone found result; breaking at i=%d\n", id, i);
                break;
            }
            working_block.nonce=i;
            if(is_good_block(&working_block, sd->target)){
                //printf("CHILD %d: I found a nonce, waiting for mutex\n", id);
                sem_wait(result_found_mutex);
                //printf("CHILD %d: I'm in the mutex\n", id);
                // *actually* make sure no one beat me to it
                if(sd->result_found){
                    printf("CHILD %d: I found a nonce, but someone beat me to it in writing it to the shared memory.\n",id);
                }else{
                    sd->result_found=1;
                    sd->block.nonce=i;
                    printf("CHILD %d: found a valid nonce %d\n", id, i);
                }
                sem_post(result_found_mutex);
                //printf("CHILD %d: I'm out of the mutex\n", id);
                break;
            }
        }
        
        // tell parent that I'm done
        sem_post(job_end_sync_sem);
    }
    
}



int main(){
    // seed the random number generator
    //srand(time(NULL));
    
    // C warm up: brute force one block
    int difficulty=0x1f03a30c;
    char target[32];
    construct_target(difficulty, &target);
    
    MerkleTreeDataNode* data1=malloc(sizeof(MerkleTreeDataNode));
    MerkleTreeDataNode* data2=malloc(sizeof(MerkleTreeDataNode));
    MerkleTreeDataNode* data3=malloc(sizeof(MerkleTreeDataNode));
    
    // These are the first three transactions of Bitcoin, spread across
    // the first three blocks on the blockchain.
    // Let's pretend we put them together in one block...
    char transaction1[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x4d, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x04, 0x45, 0x54, 0x68, 0x65, 0x20, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x20, 0x30, 0x33, 0x2f, 0x4a,
        0x61, 0x6e, 0x2f, 0x32, 0x30, 0x30, 0x39, 0x20,
        0x43, 0x68, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x6c,
        0x6f, 0x72, 0x20, 0x6f, 0x6e, 0x20, 0x62, 0x72,
        0x69, 0x6e, 0x6b, 0x20, 0x6f, 0x66, 0x20, 0x73,
        0x65, 0x63, 0x6f, 0x6e, 0x64, 0x20, 0x62, 0x61,
        0x69, 0x6c, 0x6f, 0x75, 0x74, 0x20, 0x66, 0x6f,
        0x72, 0x20, 0x62, 0x61, 0x6e, 0x6b, 0x73, 0xff,
        0xff, 0xff, 0xff, 0x01, 0x00, 0xf2, 0x05, 0x2a,
        0x01, 0x00, 0x00, 0x00, 0x43, 0x41, 0x04, 0x67,
        0x8a, 0xfd, 0xb0, 0xfe, 0x55, 0x48, 0x27, 0x19,
        0x67, 0xf1, 0xa6, 0x71, 0x30, 0xb7, 0x10, 0x5c,
        0xd6, 0xa8, 0x28, 0xe0, 0x39, 0x09, 0xa6, 0x79,
        0x62, 0xe0, 0xea, 0x1f, 0x61, 0xde, 0xb6, 0x49,
        0xf6, 0xbc, 0x3f, 0x4c, 0xef, 0x38, 0xc4, 0xf3,
        0x55, 0x04, 0xe5, 0x1e, 0xc1, 0x12, 0xde, 0x5c,
        0x38, 0x4d, 0xf7, 0xba, 0x0b, 0x8d, 0x57, 0x8a,
        0x4c, 0x70, 0x2b, 0x6b, 0xf1, 0x1d, 0x5f, 0xac,
        0x00, 0x00, 0x00, 0x00
    };
    char transaction2[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x07, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x04, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xf2,
        0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x43, 0x41,
        0x04, 0x96, 0xb5, 0x38, 0xe8, 0x53, 0x51, 0x9c,
        0x72, 0x6a, 0x2c, 0x91, 0xe6, 0x1e, 0xc1, 0x16,
        0x00, 0xae, 0x13, 0x90, 0x81, 0x3a, 0x62, 0x7c,
        0x66, 0xfb, 0x8b, 0xe7, 0x94, 0x7b, 0xe6, 0x3c,
        0x52, 0xda, 0x75, 0x89, 0x37, 0x95, 0x15, 0xd4,
        0xe0, 0xa6, 0x04, 0xf8, 0x14, 0x17, 0x81, 0xe6,
        0x22, 0x94, 0x72, 0x11, 0x66, 0xbf, 0x62, 0x1e,
        0x73, 0xa8, 0x2c, 0xbf, 0x23, 0x42, 0xc8, 0x58,
        0xee, 0xac, 0x00, 0x00, 0x00, 0x00
    };
    char transaction3[]={
        0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0xff, 0x07, 0x04, 0xff, 0xff, 0x00, 0x1d, 0x01,
        0x0b, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xf2,
        0x05, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x43, 0x41,
        0x04, 0x72, 0x11, 0xa8, 0x24, 0xf5, 0x5b, 0x50,
        0x52, 0x28, 0xe4, 0xc3, 0xd5, 0x19, 0x4c, 0x1f,
        0xcf, 0xaa, 0x15, 0xa4, 0x56, 0xab, 0xdf, 0x37,
        0xf9, 0xb9, 0xd9, 0x7a, 0x40, 0x40, 0xaf, 0xc0,
        0x73, 0xde, 0xe6, 0xc8, 0x90, 0x64, 0x98, 0x4f,
        0x03, 0x38, 0x52, 0x37, 0xd9, 0x21, 0x67, 0xc1,
        0x3e, 0x23, 0x64, 0x46, 0xb4, 0x17, 0xab, 0x79,
        0xa0, 0xfc, 0xae, 0x41, 0x2a, 0xe3, 0x31, 0x6b,
        0x77, 0xac, 0x00, 0x00, 0x00, 0x00
    };
    
    data1->length=204;
    data1->data=&transaction1;
    data2->length=134;
    data2->data=&transaction2;
    data3->length=134;
    data3->data=&transaction2;
    
    MerkleTreeHashNode* node1=malloc(sizeof(MerkleTreeHashNode));
    node1->left=NULL;
    node1->right=NULL;
    node1->data=data1;
    
    MerkleTreeHashNode* node2=malloc(sizeof(MerkleTreeHashNode));
    node2->left=NULL;
    node2->right=NULL;
    node2->data=data2;
    
    MerkleTreeHashNode* node3=malloc(sizeof(MerkleTreeHashNode));
    node3->left=NULL;
    node3->right=NULL;
    node3->data=data3;
    
    MerkleTreeHashNode* node12=malloc(sizeof(MerkleTreeHashNode));
    node12->left=node1;
    node12->right=node2;
    node12->data=NULL;
    
    MerkleTreeHashNode* node34=malloc(sizeof(MerkleTreeHashNode));
    node34->left=node3;
    node34->right=NULL;
    node34->data=NULL;
    
    MerkleTreeHashNode* node1234=malloc(sizeof(MerkleTreeHashNode));
    node1234->left=node12;
    node1234->right=node34;
    node1234->data=NULL;
    
    BitcoinBlock block;
    block.merkle_tree=node1234;
    
    update_merkle_root(&block);
    
    debug_print_hex_line(&(block.header.merkle_root), 32);
    // should be:
    // 6A9CC4EACE6C3F1EF9A5278FB66633CE3973492107F134F60FD551E48C9A948A
    
    block.header.version=4;
    memset(&(block.header.previous_block_hash), 0, 32);
    block.header.timestamp=time(NULL);
    block.header.difficulty=difficulty;
    block.header.nonce=0;
    
    for(int i=0; i<2147483647; i++){
        block.header.nonce=i;
        if(is_good_block(&(block.header), &target)){
            printf("Nonce found: %d\n", i);
            break;
        }
    }
    
    free(node1);
    free(node2);
    free(node3);
    free(node12);
    free(node34);
    free(node1234);
    
    return 0;
    
}



























